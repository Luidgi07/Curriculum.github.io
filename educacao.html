<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <title>Biblioteca 3D – Estante com Nichos e Laterais em L</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #info {
      position: fixed;
      top: 12px; left: 12px;
      background: rgba(255,255,255,0.95);
      padding: 12px 20px;
      border-radius: 8px;
      font-family: 'Segoe UI', sans-serif;
      font-size: 1.1rem;
      color: #0066bb;
      max-width: 360px;
      z-index: 20;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      display: none;
    }
    #hud {
      position: fixed;
      left: 24px; bottom: 24px;
      background: rgba(240,247,255,0.95);
      padding: 13px 22px 11px 18px;
      border-radius: 14px;
      font-family: 'Segoe UI';
      color: #083c6a;
      min-width: 210px;
      font-size: 1.1rem;
      z-index: 10;
      border: 2px solid #a5c7e6;
      user-select: none;
    }
    #hud .title { font-weight: bold; font-size: 1.05rem; margin-bottom: 8px; }
    #hud .keys { margin-top: 0; margin-bottom: 0; }
    #hud .key {
      background: #dbeafe; border-radius: 5px;
      padding: 3px 8px; margin: 0 4px;
      border: 1px solid #a5c7e6;
      font-weight: 500;
      display: inline-block;
      font-size: 1.0rem; color: #2a68b2;
    }
    #hud .desc { margin-top: 10px; font-size: 0.97rem; color: #1e3d59; }
    #closeInfo {
      margin-top: 12px;
      cursor: pointer;
      padding: 6px 12px;
      background-color: #2a68b2;
      color: white;
      border-radius: 5px;
      font-weight: 600;
      display: inline-block;
    }
  </style>
</head>
<body>
  <div id="info"></div>
  <div id="hud">
    <div class="title">Comandos:</div>
    <div class="keys">
      <span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span>
      <span class="desc">Mover personagem</span>
    </div>
    <div class="keys" style="margin-top:7px;">
      <span class="key">O</span>
      <span class="desc">Mostrar informação próxima</span>
    </div>
  </div>
  <script src="https://unpkg.com/three@0.153.0/build/three.min.js"></script>
  <script>
    // SETUP
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xe8e3d1);
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 8, 20);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // ILUMINAÇÃO
    scene.add(new THREE.AmbientLight(0xfad7a0, 0.7));
    const dirLight = new THREE.DirectionalLight(0xffe1b7, 0.85);
    dirLight.position.set(12, 22, 18);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    dirLight.shadow.camera.near = 1;
    dirLight.shadow.camera.far = 50;
    dirLight.shadow.camera.left = -20;
    dirLight.shadow.camera.right = 20;
    dirLight.shadow.camera.top = 20;
    dirLight.shadow.camera.bottom = -20;
    scene.add(dirLight);

    // CHÃO
    const chaoGeo = new THREE.BoxGeometry(20, 0.3, 20);
    const chaoMat = new THREE.MeshLambertMaterial({ color: 0xc9ad7c });
    const chao = new THREE.Mesh(chaoGeo, chaoMat);
    chao.position.y = -0.25;
    chao.receiveShadow = true;
    chao.userData.solido = true;
    scene.add(chao);

    // FUNÇÃO: Parede lateral genérica
    function criaParedeLateral(x, largura, altura, comprimento, cor = 0x7a4a21) {
      const geo = new THREE.BoxGeometry(largura, altura, comprimento);
      const mat = new THREE.MeshLambertMaterial({ color: cor });
      const parede = new THREE.Mesh(geo, mat);
      parede.position.set(x, altura / 2, -(10 - comprimento/2));
      parede.userData.solido = true;
      parede.castShadow = true;
      scene.add(parede);
      return parede;
    }

    // LATERAIS EM "L":
    // Esquerda: bloco da frente + recuo fundo
    criaParedeLateral(-9.3, 1.7, 10, 8.2); // bloco frontal da esquerda (até meio)
    criaParedeLateral(-9.3, 1.1, 10, 7.5).position.z = -10 + 7.5/2; // bloco recuado fundo esquerda

    // Direita: bloco da frente + recuo fundo
    criaParedeLateral(9.3, 1.7, 10, 8.2); // bloco frontal da direita (até meio)
    criaParedeLateral(9.3, 1.1, 10, 7.5).position.z = -10 + 7.5/2; // bloco recuado fundo direita

    // CANTOS: colunas grossas à frente
    function criaColunaCanto(x, z, altura, raio, cor = 0x9a6a3a) {
      const colGeo = new THREE.CylinderGeometry(raio, raio, altura, 18);
      const colMat = new THREE.MeshLambertMaterial({ color: cor });
      const coluna = new THREE.Mesh(colGeo, colMat);
      coluna.position.set(x, altura/2, z);
      coluna.userData.solido = true;
      coluna.castShadow = true;
      scene.add(coluna);
    }
    criaColunaCanto(-8.1, 8.7, 10.4, 1.1);
    criaColunaCanto(8.1, 8.7, 10.4, 1.1);

    // NICHOS NO FUNDO (estante traseira)
    function criaNichoEstante(x, y, z, largura, altura, profundidade, cor = 0x7a4a21) {
      const espessura = 0.6;
      const estante = new THREE.Group();
      // Base inferior
      const baseGeo = new THREE.BoxGeometry(largura, espessura, profundidade);
      const baseMat = new THREE.MeshLambertMaterial({ color: cor });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.set(0, espessura / 2, 0); base.castShadow = true; base.receiveShadow = true;
      base.userData.solido = true; estante.add(base);
      // Laterais
      const ladoGeo = new THREE.BoxGeometry(espessura, altura, profundidade);
      const ladoEsq = new THREE.Mesh(ladoGeo, baseMat);
      ladoEsq.position.set(-largura/2 + espessura/2, altura/2 + espessura, 0); ladoEsq.castShadow = true; estante.add(ladoEsq);
      ladoEsq.userData.solido = true;
      const ladoDir = ladoEsq.clone();
      ladoDir.position.x = largura/2 - espessura/2;
      estante.add(ladoDir);
      // Fundo (profundidade fina)
      const fundoGeo = new THREE.BoxGeometry(largura - espessura*2, altura, espessura);
      const fundo = new THREE.Mesh(fundoGeo, baseMat);
      fundo.position.set(0, altura/2 + espessura, -profundidade/2 + espessura/2); fundo.castShadow = true;
      fundo.receiveShadow = true; fundo.userData.solido = true; estante.add(fundo);

      estante.position.set(x, y, z);
      scene.add(estante);
      return estante;
    }
    function criaLivrosNoNicho(estante, largura, altura, profundidade, nFilas = 3, livrosPorFila = 10) {
      const livroWidth = (largura - 0.6*2) / livrosPorFila;
      const livroDepth = 0.15;
      const livroHeightBase = 0.5;
      for(let f = 0; f < nFilas; f++) {
        const py = 0.7 + f * ((altura - 1.7) / (nFilas - 1)) + 0.6;
        for(let l = 0; l < livrosPorFila; l++) {
          const lx = -largura/2 + 0.6 + (l + 0.5) * livroWidth;
          const lz = livroDepth/2 + 0.1;
          const livroGeo = new THREE.BoxGeometry(livroWidth - 0.03, livroHeightBase + Math.random() * 0.1, livroDepth);
          const livroMat = new THREE.MeshLambertMaterial({ color: Math.random() > 0.3 ? Math.floor(Math.random() * 0xffffff) : 0xdacaa7 });
          const livro = new THREE.Mesh(livroGeo, livroMat);
          livro.position.set(lx, py, lz);
          livro.castShadow = true;
          livro.receiveShadow = true;
          estante.add(livro);
        }
      }
    }
    const nichos = [];
    const larguraNicho = 5.5;
    const alturaNicho = 4;
    const profundidadeNicho = 0.65;
    for (let i = -1; i <= 1; i++) {
      const nicho = criaNichoEstante(i * (larguraNicho + 0.2), alturaNicho / 2, -9.2, larguraNicho, alturaNicho, profundidadeNicho);
      criaLivrosNoNicho(nicho, larguraNicho, alturaNicho, profundidadeNicho * 2, 3, 15);
      nichos.push(nicho);
    }

    // PRATELEIRAS EDUCATIVAS
    function criaPrat(x, z, y, texto) {
      const geo = new THREE.BoxGeometry(2.1, 2.1, 0.65);
      const mat = new THREE.MeshLambertMaterial({ color: 0xffc107 });
      const shelf = new THREE.Mesh(geo, mat);
      shelf.position.set(x, y, z);
      shelf.userData.label = texto;
      shelf.userData.interacao = true;
      shelf.userData.solido = true;
      shelf.castShadow = true;
      shelf.receiveShadow = true;
      scene.add(shelf);
      return shelf;
    }
    const prateleiras = [
      criaPrat(-5, -5, 1.6, "Licenciatura em Engenharia Biomédica<br><i>IPS/ISEL (2023- )</i><br>Projetos IA Médica, tese segmentação de tumores."),
      criaPrat(5, -5, 1.6, "Ensino Secundário<br><i>Escola Secundária de Setúbal (2019-2022)</i><br>Distinção, competição natação."),
      criaPrat(0, -2, 1.6, "Side Quests & Clubes<br><i>Clubes científicos, voluntariado, projetos extracurriculares.</i>")
    ];

    // BONECO
    function criaBoneco() {
      const grupo = new THREE.Group();
      const corpoGeo = new THREE.BoxGeometry(1, 1.6, 0.7);
      const corpoMat = new THREE.MeshLambertMaterial({ color: 0x2196f3 });
      const corpo = new THREE.Mesh(corpoGeo, corpoMat);
      corpo.position.y = 1;
      corpo.castShadow = true;
      corpo.receiveShadow = false;
      grupo.add(corpo);
      const cabecaGeo = new THREE.BoxGeometry(0.8, 0.7, 0.7);
      const cabecaMat = new THREE.MeshLambertMaterial({ color: 0xfff176 });
      const cabeca = new THREE.Mesh(cabecaGeo, cabecaMat);
      cabeca.position.y = 2;
      cabeca.castShadow = true;
      grupo.add(cabeca);
      grupo.position.set(0, 0.25, 6);
      return grupo;
    }
    const boneco = criaBoneco();
    scene.add(boneco);

    // INPUT
    const keys = {};
    document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
    document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

    // COLISÕES
    let objetosSolidos = [];
    const caixaBoneco = new THREE.Box3();
    function atualizaColisoes() {
      objetosSolidos = [];
      scene.traverse(obj => {
        if (obj.userData && obj.userData.solido && obj.geometry) {
          const box = new THREE.Box3().setFromObject(obj);
          objetosSolidos.push({obj, box});
        }
      });
    }
    atualizaColisoes();
    function colisao(nx, ny, nz) {
      const tamanhoBoneco = new THREE.Vector3(1, 1.6, 0.7);
      caixaBoneco.min.set(nx - tamanhoBoneco.x / 2, ny, nz - tamanhoBoneco.z / 2);
      caixaBoneco.max.set(nx + tamanhoBoneco.x / 2, ny + tamanhoBoneco.y, nz + tamanhoBoneco.z / 2);
      for (const {obj, box} of objetosSolidos) {
        if (caixaBoneco.intersectsBox(box)) return true;
      }
      return false;
    }

    // MOVIMENTO
    let posAtual = boneco.position.clone();
    let velocidade = new THREE.Vector3(0, 0, 0);
    const acel = 0.02;
    const friccao = 0.88;
    const maxVel = 0.15;
    let prateleiraPerto = null;
    const infoDiv = document.getElementById("info");
    function mostrarInfo(texto) {
      infoDiv.innerHTML = texto + '<br><br><span id="closeInfo">Fechar</span>';
      infoDiv.style.display = "block";
      document.getElementById("closeInfo").onclick = () => {
        infoDiv.style.display = "none";
      };
    }
    function animate() {
      if (keys["w"]) velocidade.z -= acel;
      if (keys["s"]) velocidade.z += acel;
      if (keys["a"]) velocidade.x -= acel;
      if (keys["d"]) velocidade.x += acel;
      velocidade.multiplyScalar(friccao);
      velocidade.x = Math.max(-maxVel, Math.min(maxVel, velocidade.x));
      velocidade.z = Math.max(-maxVel, Math.min(maxVel, velocidade.z));
      let nx = posAtual.x + velocidade.x;
      let ny = 0.25;
      let nz = posAtual.z + velocidade.z;
      nx = Math.max(-9, Math.min(9, nx));
      nz = Math.max(-9, Math.min(9, nz));
      if (!colisao(nx, ny, nz)) {
        posAtual.set(nx, ny, nz);
        boneco.position.copy(posAtual);
      } else {
        velocidade.set(0, 0, 0);
      }
      camera.position.lerp(new THREE.Vector3(posAtual.x, 6 + posAtual.y / 1.7, posAtual.z + 12), 0.1);
      camera.lookAt(posAtual.x, posAtual.y + 1.5, posAtual.z);
      prateleiraPerto = null;
      for(const shelf of prateleiras) {
        const dist = shelf.position.distanceTo(posAtual);
        if(dist < 2.4) {
          prateleiraPerto = shelf;
          break;
        }
      }
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // INFO
    document.addEventListener("keydown", e => {
      if (e.key.toLowerCase() === "o" && prateleiraPerto) {
        mostrarInfo(prateleiraPerto.userData.label);
      }
    });

    // RESPONSIVO
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
