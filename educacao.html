<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <title>Escritório 3D com 3 Paredes e Boneco</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #info {
      position: fixed;
      top: 10px; left: 10px;
      background: rgba(255,255,255,0.8);
      padding: 8px 12px;
      font-family: Arial, sans-serif;
      z-index: 10;
      border-radius: 6px;
    }
  </style>
</head>
<body>
<div id="info">Use W/A/S/D para mover o boneco</div>
<script src="https://unpkg.com/three@0.153.0/build/three.min.js"></script>
<script>
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xe0e0e0);

  // Câmera reposicionada para melhor vista com 3 paredes
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(10, 15, 18);
  camera.lookAt(0, 0, 0);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  // Luzes
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(10, 20, 10);
  directionalLight.castShadow = true;
  scene.add(directionalLight);

  // Chão
  const floorGeo = new THREE.PlaneGeometry(20, 20);
  const floorMat = new THREE.MeshStandardMaterial({color: 0x999999});
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);

  // Apenas 3 paredes: traseira e laterais
  const walls = [];

  function criaParede(x, y, z, rotY) {
    const geo = new THREE.BoxGeometry(20, 8, 0.3);
    const mat = new THREE.MeshStandardMaterial({color: 0xffffff});
    const parede = new THREE.Mesh(geo, mat);
    parede.position.set(x, y, z);
    if (rotY) parede.rotation.y = rotY;
    parede.receiveShadow = true;
    walls.push(parede);
    scene.add(parede);
  }

  criaParede(0, 4, -10, 0);          // parede traseira
  criaParede(-10, 4, 0, Math.PI/2); // parede esquerda
  criaParede(10, 4, 0, Math.PI/2);  // parede direita

  // Mesa simples
  const mesaGeo = new THREE.BoxGeometry(5, 0.3, 3);
  const mesaMat = new THREE.MeshStandardMaterial({color: 0x654321});
  const mesa = new THREE.Mesh(mesaGeo, mesaMat);
  mesa.position.set(0, 1.5, 0);
  mesa.castShadow = true;
  mesa.receiveShadow = true;
  scene.add(mesa);

  // Pernas da mesa
  const pernaGeo = new THREE.CylinderGeometry(0.1, 0.1, 1.5);
  const pernaMat = new THREE.MeshStandardMaterial({color: 0x3e2723});
  const posPernas = [
    [-2.3, 0.75, -1.3],
    [2.3, 0.75, -1.3],
    [-2.3, 0.75, 1.3],
    [2.3, 0.75, 1.3]
  ];
  posPernas.forEach(pos => {
    const perna = new THREE.Mesh(pernaGeo, pernaMat);
    perna.position.set(...pos);
    perna.castShadow = true;
    scene.add(perna);
  });

  // Boneco simples (grupo)
  function criaBoneco() {
    const grupo = new THREE.Group();

    const corpoGeo = new THREE.BoxGeometry(1, 1.6, 0.7);
    const corpoMat = new THREE.MeshStandardMaterial({color: 0x2196f3});
    const corpo = new THREE.Mesh(corpoGeo, corpoMat);
    corpo.position.y = 0.8;
    corpo.castShadow = true;
    grupo.add(corpo);

    const cabecaGeo = new THREE.BoxGeometry(0.8, 0.7, 0.7);
    const cabecaMat = new THREE.MeshStandardMaterial({color: 0xfff176});
    const cabeca = new THREE.Mesh(cabecaGeo, cabecaMat);
    cabeca.position.y = 2;
    cabeca.castShadow = true;
    grupo.add(cabeca);

    grupo.position.set(0, 0, 5);
    return grupo;
  }
  const boneco = criaBoneco();
  scene.add(boneco);

  // Controles W/A/S/D
  const keys = {};
  window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
  window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

  // Colisão simples com paredes (caixas)
  const bonecoBox = new THREE.Box3();
  const wallBoxes = [];

  function atualizaWallBoxes() {
    wallBoxes.length = 0;
    walls.forEach(wall => {
      const box = new THREE.Box3().setFromObject(wall);
      wallBoxes.push(box);
    });
  }
  atualizaWallBoxes();

  // Movimento do boneco com colisão
  const velocidade = 0.1;
  function moverBoneco() {
    let dx = 0, dz = 0;
    if (keys['w']) dz -= velocidade;
    if (keys['s']) dz += velocidade;
    if (keys['a']) dx -= velocidade;
    if (keys['d']) dx += velocidade;

    const posAtual = boneco.position.clone();
    const novaPos = posAtual.clone();
    novaPos.x += dx;
    novaPos.z += dz;

    const tamanhoBoneco = new THREE.Vector3(1, 1.6, 0.7);
    const caixaTeste = new THREE.Box3(
      new THREE.Vector3(novaPos.x - tamanhoBoneco.x/2, 0, novaPos.z - tamanhoBoneco.z/2),
      new THREE.Vector3(novaPos.x + tamanhoBoneco.x/2, tamanhoBoneco.y, novaPos.z + tamanhoBoneco.z/2)
    );

    let colisao = false;
    for(const box of wallBoxes) {
      if(caixaTeste.intersectsBox(box)) {
        colisao = true;
        break;
      }
    }

    if(!colisao) {
      boneco.position.copy(novaPos);
    }
  }

  // Animação
  function animate() {
    requestAnimationFrame(animate);
    moverBoneco();
    renderer.render(scene, camera);
  }
  animate();

  // Ajuste responsivo
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
