<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <title>Escritório 3D com Boneco Andando</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #info {
      position: fixed;
      top: 10px; left: 10px;
      background: rgba(255,255,255,0.8);
      padding: 8px 12px;
      font-family: Arial, sans-serif;
      z-index: 10;
      border-radius: 6px;
    }
  </style>
</head>
<body>
<div id="info">Use W/A/S/D para mover o boneco</div>
<script src="https://unpkg.com/three@0.153.0/build/three.min.js"></script>
<script>
  // Cena
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xe0e0e0);

  // Câmera
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(6, 10, 12);
  camera.lookAt(0, 0, 0);

  // Renderer
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  // Luzes
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);

  const spotLight = new THREE.SpotLight(0xffffff, 0.8);
  spotLight.position.set(0, 15, 10);
  spotLight.castShadow = true;
  scene.add(spotLight);

  // Chão
  const floorGeo = new THREE.PlaneGeometry(20, 20);
  const floorMat = new THREE.MeshStandardMaterial({color: 0x999999});
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);

  // Paredes (4)
  function criarParede(x, y, z, rotY) {
    const geo = new THREE.BoxGeometry(20, 8, 0.3);
    const mat = new THREE.MeshStandardMaterial({color: 0xffffff});
    const parede = new THREE.Mesh(geo, mat);
    parede.position.set(x,y,z);
    if(rotY) parede.rotation.y = rotY;
    parede.receiveShadow = true;
    walls.push(parede);
    scene.add(parede);
  }
  const walls = [];
  criarParede(0, 4, -10);
  criarParede(0, 4, 10);
  criarParede(-10, 4, 0, Math.PI/2);
  criarParede(10, 4, 0, Math.PI/2);

  // Mesa
  const mesaGeo = new THREE.BoxGeometry(5, 0.3, 3);
  const mesaMat = new THREE.MeshStandardMaterial({color: 0x654321});
  const mesa = new THREE.Mesh(mesaGeo, mesaMat);
  mesa.position.set(0, 1.5, 0);
  mesa.castShadow = true;
  mesa.receiveShadow = true;
  scene.add(mesa);

  // Pernas da mesa
  const pernaGeo = new THREE.CylinderGeometry(0.1, 0.1, 1.5);
  const pernaMat = new THREE.MeshStandardMaterial({color: 0x3e2723});
  const posPernas = [[-2.3,0.75,-1.3],[2.3,0.75,-1.3],[-2.3,0.75,1.3],[2.3,0.75,1.3]];
  posPernas.forEach(pos=>{
    const perna = new THREE.Mesh(pernaGeo, pernaMat);
    perna.position.set(...pos);
    perna.castShadow = true;
    scene.add(perna);
  });

  // Boneco (grupo)
  function criaBoneco() {
    const grupo = new THREE.Group();

    const corpoGeo = new THREE.BoxGeometry(1, 1.6, 0.7);
    const corpoMat = new THREE.MeshStandardMaterial({color: 0x2196f3});
    const corpo = new THREE.Mesh(corpoGeo, corpoMat);
    corpo.position.y = 0.8;
    corpo.castShadow = true;
    grupo.add(corpo);

    const cabecaGeo = new THREE.BoxGeometry(0.8, 0.7, 0.7);
    const cabecaMat = new THREE.MeshStandardMaterial({color: 0xfff176});
    const cabeca = new THREE.Mesh(cabecaGeo, cabecaMat);
    cabeca.position.y = 2;
    cabeca.castShadow = true;
    grupo.add(cabeca);

    grupo.position.set(0, 0, 5);
    return grupo;
  }
  const boneco = criaBoneco();
  scene.add(boneco);

  // Controles de movimento
  const keys = {};
  window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
  window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

  // Função para colisão simplificada com paredes (caixas)
  const bonecoBox = new THREE.Box3();
  const wallBoxes = [];

  function atualizaWallBoxes() {
    wallBoxes.length = 0;
    walls.forEach(wall => {
      const box = new THREE.Box3().setFromObject(wall);
      wallBoxes.push(box);
    });
  }
  atualizaWallBoxes();

  // Movimento
  const velocidade = 0.1;
  function moverBoneco() {
    let dx = 0, dz = 0;
    if(keys['w']) dz -= velocidade;
    if(keys['s']) dz += velocidade;
    if(keys['a']) dx -= velocidade;
    if(keys['d']) dx += velocidade;

    const posAtual = boneco.position.clone();
    const novaPos = posAtual.clone();
    novaPos.x += dx;
    novaPos.z += dz;

    bonecoBox.setFromObject(boneco);

    // Testa colisão na nova posição
    const tamanhoBoneco = new THREE.Vector3(1, 1.6, 0.7);
    const caixaTeste = new THREE.Box3(
      new THREE.Vector3(novaPos.x - tamanhoBoneco.x/2, 0, novaPos.z - tamanhoBoneco.z/2),
      new THREE.Vector3(novaPos.x + tamanhoBoneco.x/2, tamanhoBoneco.y, novaPos.z + tamanhoBoneco.z/2)
    );

    let colisao = false;
    for(const box of wallBoxes) {
      if(caixaTeste.intersectsBox(box)) {
        colisao = true;
        break;
      }
    }

    if(!colisao){
      boneco.position.copy(novaPos);
    }
  }

  // Loop animação
  function animate() {
    requestAnimationFrame(animate);
    moverBoneco();
    renderer.render(scene, camera);
  }
  animate();

  // Resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
