<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <title>Escritório Interrogatório — Câmara Centrada</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #info {
      position: fixed; top: 14px; left: 14px;
      background: rgba(255,255,255,0.94);
      padding: 10px 20px;
      border-radius: 7px;
      font-family: Arial, sans-serif;
      font-size: 1.05em;
      z-index: 10;
      box-shadow: 0 2px 10px rgba(100,100,130,0.13);
    }
  </style>
</head>
<body>
<div id="info">
  <b>W/A/S/D</b> mover boneco<br>
  Porta abre ao aproximar<br>
  Vista centrada, "lá de fora", pela abertura<br>
  Não podes sair da sala!
</div>
<script src="https://unpkg.com/three@0.153.0/build/three.min.js"></script>
<script>
const roomW = 20, roomH = 8, roomL = 20, paredeEsp = 0.3, gapAbertura = 7;

// === SCENE ===
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf0f0f0);

// === LUZ ===
scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
dirLight.position.set(14, 18, 21);
scene.add(dirLight);

// === CHÃO ===
const floorGeo = new THREE.PlaneGeometry(roomW, roomL);
const floorMat = new THREE.MeshStandardMaterial({color: 0xaab2bb});
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI / 2;
scene.add(floor);

// === PAREDES ===
const paredeMat = new THREE.MeshStandardMaterial({color: 0xffffff});
const paredeAzulMat = new THREE.MeshStandardMaterial({color: 0xb0e0fe});

function parede(x, y, z, sx, sy, sz, mat=paredeMat) {
  const mesh = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz), mat);
  mesh.position.set(x, y, z);
  scene.add(mesh);
  return mesh;
}

// Traseira
parede(0, roomH/2, -roomL/2 + paredeEsp/2, roomW, roomH, paredeEsp);
// Direita
parede(roomW/2 - paredeEsp/2, roomH/2, 0, paredeEsp, roomH, roomL);
// Esquerda
parede(-roomW/2 + paredeEsp/2, roomH/2, 0, paredeEsp, roomH, roomL);
// Frente (paredes laterais: há um “gap” de abertura)
const aberturaZ = roomL/2 - paredeEsp/2;
const aberturaLados = (roomW-gapAbertura)/2;
parede(-roomW/2 + aberturaLados/2, roomH/2, aberturaZ, aberturaLados, roomH, paredeEsp); // esquerda abertura
parede(roomW/2 - aberturaLados/2, roomH/2, aberturaZ, aberturaLados, roomH, paredeEsp); // direita abertura

// === BLOCO DE PAREDE SOBRE A PORTA ===
// Posição: a meio da abertura, logo acima do batente da porta
const blocoCimaAltura = roomH - 2.6;
parede(0, roomH - blocoCimaAltura/2, aberturaZ, gapAbertura, blocoCimaAltura, paredeEsp, paredeAzulMat);

// === PORTA ===
const portaAltura = 2.6, portaLargura = 1.4;
const portaGeo = new THREE.BoxGeometry(paredeEsp+0.05, portaAltura, portaLargura);
const portaMat = new THREE.MeshStandardMaterial({color: 0x764621});
const porta = new THREE.Mesh(portaGeo, portaMat);
const pivotPorta = new THREE.Object3D();
const portaY = portaAltura/2 + 0.12;
const portaZ = aberturaZ - 0.001;
pivotPorta.position.set(0, portaY, portaZ);
porta.position.set(0, 0, portaLargura/2);
pivotPorta.add(porta);
scene.add(pivotPorta);
let portaAberta = false;

// === INVISÍVEL: BARREIRA NA ABERTURA ===
// Para impedir boneco de sair
const barreiraGap = new THREE.Mesh(
  new THREE.BoxGeometry(gapAbertura, roomH, paredeEsp*0.99),
  new THREE.MeshBasicMaterial({ color: 0x00ff00, visible: false })
);
barreiraGap.position.set(0, roomH/2, roomL/2 - paredeEsp/2 + 0.02);
scene.add(barreiraGap);

// === MESA ===
const mesaGeo = new THREE.BoxGeometry(3.4, 0.32, 1.5);
const mesaMat = new THREE.MeshStandardMaterial({color: 0x7b4b22});
const mesa = new THREE.Mesh(mesaGeo, mesaMat);
mesa.position.set(-2, 1.15, -3.6);
scene.add(mesa);
for(let dx of [-1.3,1.3]) for(let dz of [-0.5,0.5]){
  const perna = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.09, 1.1), new THREE.MeshStandardMaterial({color: 0x4d3319}));
  perna.position.set(mesa.position.x + dx, 0.6, mesa.position.z + dz);
  scene.add(perna);
}

// === ESPELHO ===
const espMat = new THREE.MeshStandardMaterial({ color: 0x8ec6ff, metalness: 1, roughness: 0, transparent:true, opacity:0.62 });
const espelho = new THREE.Mesh(
  new THREE.BoxGeometry(0.21, roomH/2.4, 4),
  espMat
);
espelho.position.set(-6.7, 1.4, 0);
scene.add(espelho);

// === BONECO ===
function criaBoneco() {
  const grupo = new THREE.Group();
  const corpo = new THREE.Mesh(new THREE.BoxGeometry(0.68, 1.12, 0.48), new THREE.MeshStandardMaterial({color: 0x389be5}));
  corpo.position.y = 0.6; grupo.add(corpo);
  const cabeca = new THREE.Mesh(new THREE.BoxGeometry(0.44, 0.41, 0.44), new THREE.MeshStandardMaterial({color: 0xf6e44d}));
  cabeca.position.y = 1.22; grupo.add(cabeca);
  grupo.position.set(0, 0, 0); // Coloca ao centro da sala
  return grupo;
}
const boneco = criaBoneco();
scene.add(boneco);

// === CONTROLO ===
const keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
function atualizaBarreiras() {
  barreiraGap.updateMatrixWorld();
  porta.updateMatrixWorld();
}
function moverBoneco() {
  const speed = 0.13; let dx=0,dz=0;
  if (keys['w']) dz -= speed;
  if (keys['s']) dz += speed;
  if (keys['a']) dx -= speed;
  if (keys['d']) dx += speed;
  const tam = new THREE.Vector3(0.68,1.12,0.48);
  const novaPos = boneco.position.clone().add(new THREE.Vector3(dx,0,dz));
  const caixa = new THREE.Box3(
    new THREE.Vector3(novaPos.x-tam.x/2, 0, novaPos.z-tam.z/2),
    new THREE.Vector3(novaPos.x+tam.x/2, tam.y, novaPos.z+tam.z/2)
  );
  atualizaBarreiras();
  let colisao = false;
  // Paredes e barreira invisível
  const listaColisao = [barreiraGap];
  for (let wall of listaColisao) {
    let box = new THREE.Box3().setFromObject(wall);
    if (caixa.intersectsBox(box)) { colisao = true; break; }
  }
  // Porta fechada é barreira
  if (!portaAberta) {
    let boxPorta = new THREE.Box3().setFromObject(porta);
    porta.updateWorldMatrix(true, false);
    boxPorta.applyMatrix4(porta.matrixWorld);
    if (caixa.intersectsBox(boxPorta)) colisao = true;
  }
  portaAberta = boneco.position.distanceTo(pivotPorta.position) < 1.2;
  if (!colisao) boneco.position.copy(novaPos);
}

// === CÂMARA ===
// Vista centrada, altura média, olhando para fundo da sala
const camera = new THREE.PerspectiveCamera(57, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 4.5, roomL/2 + 7); // centrada, afastada do centro da abertura
camera.lookAt(0, 3.4, 0);

// === RENDERER ===
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// === ANIMAÇÃO ===
function animarPorta(proximo) {
  const destino = proximo ? Math.PI/2 : 0;
  if (Math.abs(pivotPorta.rotation.y - destino) > 0.01)
    pivotPorta.rotation.y += (destino - pivotPorta.rotation.y) * 0.23;
}
function animate() {
  requestAnimationFrame(animate);
  moverBoneco();
  animarPorta(portaAberta);
  renderer.render(scene, camera);
}
animate();
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
