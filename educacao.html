<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <title>Escritório Interrogatório — Câmara Segue Boneco</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #info {
      position: fixed;
      top: 12px; left: 12px;
      background: rgba(255,255,255,0.85);
      padding: 10px 18px;
      border-radius: 6px;
      font-family: Arial, sans-serif;
      font-size: 1.1em;
      z-index: 10;
    }
  </style>
</head>
<body>
<div id="info">Usa W/A/S/D para mexer o boneco. A porta abre ao aproximar!</div>
<script src="https://unpkg.com/three@0.153.0/build/three.min.js"></script>
<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xe0e0e0);

// Parâmetros de sala/estruturas
const roomW = 20, roomH = 8, roomL = 20;
const paredeEsp = 0.3;
const paredeFalsaGap = 4;

// Câmera: começa atrás e acima do boneco
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// Luzes
scene.add(new THREE.AmbientLight(0xffffff, 0.75));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
dirLight.position.set(0, 30, 14);
dirLight.castShadow = true;
scene.add(dirLight);

// Chão
const floorGeo = new THREE.PlaneGeometry(roomW, roomL);
const floorMat = new THREE.MeshStandardMaterial({color: 0xaaaaaa});
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);

// Paredes
const walls = [];
function criaParede(x, y, z, sx, sy, sz) {
  const geo = new THREE.BoxGeometry(sx, sy, sz);
  const mat = new THREE.MeshStandardMaterial({color: 0xffffff});
  const parede = new THREE.Mesh(geo, mat);
  parede.position.set(x, y, z);
  parede.receiveShadow = true;
  walls.push(parede);
  scene.add(parede);
}
criaParede(0, roomH/2, -roomL/2 + paredeEsp/2, roomW, roomH, paredeEsp);
criaParede(-roomW/2 + paredeEsp/2, roomH/2, 0, paredeEsp, roomH, roomL);
criaParede(roomW/2 - paredeEsp/2, roomH/2, 0, paredeEsp, roomH, roomL);

// Parede falsa paralela à esquerda
const paredeFalsaX = -roomW/2 + paredeEsp + paredeFalsaGap;
const paredeFalsaY = roomH/2;
const paredeFalsaZ = 0;
const paredeFalsaL = roomL;
const paredeFalsaH = roomH;
const paredeFalsaE = paredeEsp;
const paredeFalsaGeo = new THREE.BoxGeometry(paredeFalsaE, paredeFalsaH, paredeFalsaL);
const paredeFalsaMat = new THREE.MeshStandardMaterial({color: 0xf0f0f0});
const paredeFalsa = new THREE.Mesh(paredeFalsaGeo, paredeFalsaMat);
paredeFalsa.position.set(paredeFalsaX, paredeFalsaY, paredeFalsaZ);
paredeFalsa.castShadow = true;
walls.push(paredeFalsa);
scene.add(paredeFalsa);

// Espelho na parede falsa
const espHeight = paredeFalsaH/2.1, espLength = paredeFalsaL/2;
const espGeo = new THREE.BoxGeometry(paredeFalsaE+0.02, espHeight, espLength);
const espMat = new THREE.MeshStandardMaterial({
  color: 0xeeeeff, metalness:1, roughness:0, transparent:true, opacity:0.87
});
const espelho = new THREE.Mesh(espGeo, espMat);
espelho.position.set(paredeFalsaX + paredeFalsaE/2 + 0.011, paredeFalsaY+1, 0);
scene.add(espelho);

// Porta animada
const portaAltura = 2.5, portaLargura = 1.25;
const portaGeo = new THREE.BoxGeometry(paredeFalsaE+0.01, portaAltura, portaLargura);
const portaMat = new THREE.MeshStandardMaterial({color: 0x654321});
const porta = new THREE.Mesh(portaGeo, portaMat);
const pivotPorta = new THREE.Object3D();
const portaCentroY = portaAltura/2 + 0.8;
const portaZ = roomL/2 - portaLargura/2 - 1.2;
pivotPorta.position.set(paredeFalsaX + paredeFalsaE/2, portaCentroY, portaZ);
porta.position.set(0, 0, portaLargura/2);
pivotPorta.add(porta);
scene.add(pivotPorta);

// Mesa ajustada
const mesaGeo = new THREE.BoxGeometry(4, 0.3, 2.2);
const mesaMat = new THREE.MeshStandardMaterial({color: 0x81603a});
const mesa = new THREE.Mesh(mesaGeo, mesaMat);
mesa.position.set(paredeFalsaX + 3.6, 1.35, -2.2);
mesa.castShadow = true;
mesa.receiveShadow = true;
scene.add(mesa);
[
  [-1.45, 0.75, -0.8],
  [1.45, 0.75, -0.8],
  [-1.45, 0.75, 0.8],
  [1.45, 0.75, 0.8]
].forEach(pos => {
  const perna = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.09, 1.3), mesaMat);
  perna.position.set(mesa.position.x + pos[0], pos[1], mesa.position.z + pos[2]);
  scene.add(perna);
});

// Boneco
function criaBoneco() {
  const grupo = new THREE.Group();
  const corpoGeo = new THREE.BoxGeometry(0.8, 1.4, 0.5);
  const corpoMat = new THREE.MeshStandardMaterial({color: 0x2196f3});
  const corpo = new THREE.Mesh(corpoGeo, corpoMat);
  corpo.position.y = 0.7;
  grupo.add(corpo);
  const cabecaGeo = new THREE.BoxGeometry(0.5, 0.45, 0.5);
  const cabecaMat = new THREE.MeshStandardMaterial({color: 0xfff176});
  const cabeca = new THREE.Mesh(cabecaGeo, cabecaMat);
  cabeca.position.y = 1.28;
  grupo.add(cabeca);
  grupo.position.set(paredeFalsaX + 2.2, 0, -4);
  return grupo;
}
const boneco = criaBoneco();
scene.add(boneco);

// CONTROL E COLISÃO
const keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

const bonecoBox = new THREE.Box3();
const wallBoxes = [];
function atualizaWallBoxes() {
  wallBoxes.length = 0;
  walls.forEach(wall => wallBoxes.push(new THREE.Box3().setFromObject(wall)));
  if (!portaAberta) {
    const caixaPorta = new THREE.Box3().setFromObject(porta);
    porta.updateWorldMatrix(true, false);
    caixaPorta.applyMatrix4(porta.matrixWorld);
    wallBoxes.push(caixaPorta);
  }
}
atualizaWallBoxes();

let portaAberta = false;
function animarPorta(proximo) {
  const destino = proximo ? Math.PI/2 : 0;
  const vel = 0.15;
  if (Math.abs(pivotPorta.rotation.y - destino) > 0.01) {
    pivotPorta.rotation.y += (destino - pivotPorta.rotation.y) * vel;
  }
}

const velocidade = 0.11;
function moverBoneco() {
  let dx = 0, dz = 0;
  if (keys['w']) dz -= velocidade;
  if (keys['s']) dz += velocidade;
  if (keys['a']) dx -= velocidade;
  if (keys['d']) dx += velocidade;
  const posAtual = boneco.position.clone();
  const novaPos = posAtual.clone();
  novaPos.x += dx; novaPos.z += dz;
  const tamanho = new THREE.Vector3(0.8, 1.4, 0.5);
  const caixaTeste = new THREE.Box3(
    new THREE.Vector3(novaPos.x - tamanho.x/2, 0, novaPos.z - tamanho.z/2),
    new THREE.Vector3(novaPos.x + tamanho.x/2, tamanho.y, novaPos.z + tamanho.z/2)
  );
  atualizaWallBoxes();
  let colisao = false;
  for(const box of wallBoxes) {
    if(caixaTeste.intersectsBox(box)) { colisao = true; break; }
  }
  const distPorta = boneco.position.distanceTo(pivotPorta.position);
  portaAberta = distPorta < 1.4;
  if(!colisao) boneco.position.copy(novaPos);
}

// --- CÂMARA SEGUE O BONECO ---
function atualizaCamera() {
  // Offset relativo ao boneco: ligeiramente atrás, acima e à direita
  const offset = new THREE.Vector3(5, 9, 12);
  const alvo = boneco.position.clone();
  const alvoCamera = alvo.clone().add(offset);
  camera.position.lerp(alvoCamera, 0.17); // suavidade
  camera.lookAt(alvo.x, alvo.y + 1, alvo.z);
}

function animate() {
  requestAnimationFrame(animate);
  moverBoneco();
  animarPorta(portaAberta);
  atualizaCamera();
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>

