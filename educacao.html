<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <title>Escritório Interrogatório — Sem Bugs</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #info { 
      position: fixed; 
      top: 14px; left: 14px; 
      background: rgba(255,255,255,0.94); 
      padding: 10px 20px; 
      border-radius: 7px; 
      font-family: Arial, sans-serif; 
      font-size: 1.05em; 
      z-index: 10; 
      box-shadow: 0 2px 10px rgba(100,100,130,0.13);
    }
  </style>
</head>
<body>
<div id="info">
  <b>W/A/S/D</b> mover boneco<br>
  Porta abre ao aproximar<br>
  Vista: de frente, inclinada do lado aberto
</div>
<script src="https://unpkg.com/three@0.153.0/build/three.min.js"></script>
<script>
const roomW = 20, roomH = 8, roomL = 20, paredeEsp = 0.3, gapFalsa = 4;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf0f0f0);

// ======= LUZ =======
scene.add(new THREE.AmbientLight(0xffffff, 0.33));
const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
dirLight.position.set(14, 18, 21);
dirLight.castShadow = true;
scene.add(dirLight);

// ======= CHÃO =======
const floorGeo = new THREE.PlaneGeometry(roomW, roomL);
const floorMat = new THREE.MeshStandardMaterial({color: 0xaab2bb});
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);

// ======= PAREDES =======
const paredeMat = new THREE.MeshStandardMaterial({color: 0xffffff});
const paredeLatMat = new THREE.MeshStandardMaterial({color: 0xd8dee9});
const walls = [];
function parede(x, y, z, sx, sy, sz, mat=paredeMat) {
  const mesh = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz), mat);
  mesh.position.set(x, y, z);
  mesh.receiveShadow = true;
  scene.add(mesh);
  walls.push(mesh);
  return mesh;
}
parede(0, roomH/2, -roomL/2 + paredeEsp/2, roomW, roomH, paredeEsp); // Traseira
const esquerda = parede(-roomW/2 + paredeEsp/2, roomH/2, 0, paredeEsp, roomH, roomL, paredeLatMat); // Esquerda destacada
parede(roomW/2 - paredeEsp/2, roomH/2, 0, paredeEsp, roomH, roomL); // Direita

// ======= PAREDE FALSA (paralela à esquerda) =======
const paredeFalsaX = -roomW/2 + paredeEsp + gapFalsa;
const paredeFalsaY = roomH/2;
const paredeFalsaL = roomL-4; // ligeiramente menor para notar a diferença
const paredeFalsaMat = new THREE.MeshStandardMaterial({color: 0xb0e0fe});
const paredeFalsa = new THREE.Mesh(
  new THREE.BoxGeometry(paredeEsp, roomH, paredeFalsaL), paredeFalsaMat
);
paredeFalsa.position.set(paredeFalsaX, paredeFalsaY, 0);
paredeFalsa.castShadow = true;
scene.add(paredeFalsa);
walls.push(paredeFalsa);

// ======= ESPELHO =======
const espMat = new THREE.MeshStandardMaterial({
  color: 0x89a7ff, metalness:1, roughness:0, transparent:true, opacity:0.73
});
const espelho = new THREE.Mesh(
  new THREE.BoxGeometry(paredeEsp+0.01, roomH/2.2, paredeFalsaL/2.6), 
  espMat
);
espelho.position.set(paredeFalsaX + paredeEsp/2 + 0.02, paredeFalsaY+1.25, 0);
scene.add(espelho);

// ======= PORTA ANIMADA =======
const portaAltura = 1.5, portaLargura = 0.8;
const portaGeo = new THREE.BoxGeometry(paredeEsp+0.05, portaAltura, portaLargura);
const portaMat = new THREE.MeshStandardMaterial({color: 0x764621});
const porta = new THREE.Mesh(portaGeo, portaMat);
const pivotPorta = new THREE.Object3D();
const portaY = portaAltura/2 + 0.1;
const portaZ = paredeFalsaL/2 - portaLargura/2 - 0.25;
pivotPorta.position.set(paredeFalsaX + paredeEsp/2, portaY, portaZ);
porta.position.set(0, 0, portaLargura/2);
pivotPorta.add(porta);
scene.add(pivotPorta);
let portaAberta = false; // ← Está AGORA definida ANTES de ser usada!

// ======= MESA =======
const mesaGeo = new THREE.BoxGeometry(3.4, 0.32, 1.5);
const mesaMat = new THREE.MeshStandardMaterial({color: 0x7b4b22});
const mesa = new THREE.Mesh(mesaGeo, mesaMat);
mesa.position.set(paredeFalsaX + 4, 1.15, -1.4);
mesa.castShadow = true;
scene.add(mesa);
for(let dx of [-1.3,1.3]) for(let dz of [-0.5,0.5]){
  const perna = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.09, 1.1), new THREE.MeshStandardMaterial({color: 0x4d3319}));
  perna.position.set(mesa.position.x + dx, 0.6, mesa.position.z + dz);
  scene.add(perna);
}

// ======= BONECO =======
function criaBoneco() {
  const grupo = new THREE.Group();
  const corpo = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.1, 0.4), new THREE.MeshStandardMaterial({color: 0x389be5}));
  corpo.position.y = 0.55;
  grupo.add(corpo);
  const cabeca = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.37, 0.4), new THREE.MeshStandardMaterial({color: 0xf6e44d}));
  cabeca.position.y = 1.14;
  grupo.add(cabeca);
  grupo.position.set(paredeFalsaX + 2.4, 0, -2.2);
  return grupo;
}
const boneco = criaBoneco();
scene.add(boneco);

// ======= CONTROL E COLISÃO =======
const keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

const wallBoxes = [];
function atualizaWallBoxes() {
  wallBoxes.length = 0;
  [esquerda, paredeFalsa, ...walls.filter(w=>w!==esquerda && w!==paredeFalsa)].forEach(wall => wallBoxes.push(new THREE.Box3().setFromObject(wall)));
  if (!portaAberta) {
    const caixaPorta = new THREE.Box3().setFromObject(porta);
    porta.updateWorldMatrix(true, false);
    caixaPorta.applyMatrix4(porta.matrixWorld);
    wallBoxes.push(caixaPorta);
  }
}

function animarPorta(proximo) {
  const destino = proximo ? Math.PI/2 : 0;
  if (Math.abs(pivotPorta.rotation.y - destino) > 0.01)
    pivotPorta.rotation.y += (destino - pivotPorta.rotation.y) * 0.23;
}

function moverBoneco() {
  const speed = 0.12; let dx=0,dz=0;
  if (keys['w']) dz -= speed;
  if (keys['s']) dz += speed;
  if (keys['a']) dx -= speed;
  if (keys['d']) dx += speed;
  const posAtual = boneco.position.clone(), novaPos = posAtual.clone();
  novaPos.x += dx; novaPos.z += dz;
  const tam = new THREE.Vector3(0.6,1.1,0.4);
  const caixa = new THREE.Box3(
    new THREE.Vector3(novaPos.x-tam.x/2, 0, novaPos.z-tam.z/2),
    new THREE.Vector3(novaPos.x+tam.x/2, tam.y, novaPos.z+tam.z/2)
  );
  atualizaWallBoxes();
  let colisao = false;
  for(const box of wallBoxes) if(caixa.intersectsBox(box)) {colisao=true;break;}
  portaAberta = boneco.position.distanceTo(pivotPorta.position) < 1.2;
  if(!colisao) boneco.position.copy(novaPos);
}

// ======= CÂMARA =======
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
// "de frente e inclinada a partir da lateral aberta"
camera.position.set(18, 13, 16);
camera.lookAt(0, 3, 0);

// ======= RENDERER =======
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

function animate() {
  requestAnimationFrame(animate);
  moverBoneco();
  animarPorta(portaAberta);
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
